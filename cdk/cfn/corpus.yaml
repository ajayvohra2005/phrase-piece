AWSTemplateFormatVersion: 2010-09-09
Description: >-
  Phrase-piece infrastructure.
Parameters:

  CodeBucket:
    Description: >-
     Code  bucket name, which must be 3 to 63 characters long, 
     and must begin and end with letter or number. This bucket must exist.
     It is used to upload Lambda function code zip files.
    Type: String
    AllowedPattern: '[a-zA-Z0-9][a-zA-Z0-9-\.]{2,62}[a-zA-Z0-9]'

  UniverseBucket:
    Description: >-
     Universe  bucket name, which must be 3 to 63 characters long, 
     and must begin and end with letter or number. This bucket must exist.
     It is used to upload Lambda function code zip files.
    Type: String
    AllowedPattern: '[a-zA-Z0-9][a-zA-Z0-9-\.]{2,62}[a-zA-Z0-9]'

  VpcCIDR:
    Default: 172.30.0.0/16
    Description: (Advanced) Vpc CIDR. Do not use 192.168.0.0 range.
    AllowedPattern: '(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})'
    Type: String

  VpcPublicSubnet1CIDR:
    Default: 172.30.0.0/24
    Description: (Advanced) Public Subnet1 CIDR inside VpcCIDR
    AllowedPattern: '(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})'
    Type: String

  VpcPublicSubnet2CIDR:
    Default: 172.30.1.0/24
    Description: (Advanced) Public Subnet2 CIDR inside VpcCIDR
    AllowedPattern: '(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})'
    Type: String

  VpcPublicSubnet3CIDR:
    Default: 172.30.2.0/24
    Description: (Advanced)  Public Subnet3 CIDR inside VpcCIDR
    AllowedPattern: '(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})'
    Type: String

  VpcPrivateSubnet1CIDR:
    Default: 172.30.64.0/18
    Description: (Advanced)  Private Subnet1 CIDR inside VpcCIDR
    AllowedPattern: '(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})'
    Type: String

  VpcPrivateSubnet2CIDR:
    Default: 172.30.128.0/18
    Description: (Advanced)  Private Subnet2 CIDR inside VpcCIDR
    AllowedPattern: '(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})'
    Type: String

  VpcPrivateSubnet3CIDR:
    Default: 172.30.192.0/18
    Description: (Advanced)  Private Subnet2 CIDR inside VpcCIDR
    AllowedPattern: '(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})'
    Type: String

  BatchComputeMax:
    Description: Maximum size of compute environment in vCpus
    Type: Number
    Default: 1024
  
  BatchComputeType:
    Description: Batch environment compute type
    Type: String
    Default: "FARGATE"
    AllowedValues:
      - "FARGATE"

  BatchImageEcrUri:
    Description: Batch image ECR URI 
    Type: String

  BatchCpuInferenceImageEcrUri:
    Description: Batch CPU inference image ECR URI 
    Type: String

  LambdaFunctionsVersion:
    Description: Lambda functions version
    Type: String
    Default: "v1.0.0"

  ScriptsVersion:
    Description: Scripts version
    Type: String
    Default: "v1.0.0"

Resources:

  KMSKey:
    Type: "AWS::KMS::Key"
    Properties:
      EnableKeyRotation: true
      KeyPolicy: {
        "Version": "2012-10-17",
        "Statement": [
           {
             "Sid": "Enable IAM User Permissions",
             "Effect": "Allow",
             "Principal": {
                "AWS": !Sub "arn:aws:iam::${AWS::AccountId}:root"
             },
             "Action": "kms:*",
             "Resource": "*"
          },
          {
            "Effect": "Allow",
            "Principal": {
                "Service": !Sub "logs.${AWS::Region}.amazonaws.com"
            },
            "Action": [
                "kms:Encrypt*",
                "kms:Decrypt*",
                "kms:ReEncrypt*",
                "kms:GenerateDataKey*",
                "kms:Describe*"
            ],
            "Resource": "*"
          }    
        ]
      }


  Vpc:
    Type: 'AWS::EC2::VPC'
    Properties:
      CidrBlock: !Ref VpcCIDR
      EnableDnsSupport: true
      EnableDnsHostnames: true
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}'

  VpcFlowLogRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service: 'vpc-flow-logs.amazonaws.com'
          Action: 'sts:AssumeRole'
      Policies:
      - PolicyName: 'flowlogs-policy'
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - 'logs:CreateLogStream'
            - 'logs:PutLogEvents'
            - 'logs:DescribeLogGroups'
            - 'logs:DescribeLogStreams'
            Resource: !GetAtt VpcFlowLogGroup.Arn
  VpcFlowLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      RetentionInDays: 14
      KmsKeyId: !GetAtt  KMSKey.Arn
      
  VpcFlowLog:
    Type: 'AWS::EC2::FlowLog'
    Properties:
      DeliverLogsPermissionArn: !GetAtt VpcFlowLogRole.Arn
      LogGroupName: !Ref VpcFlowLogGroup
      ResourceId: !Ref Vpc
      ResourceType: 'VPC'
      TrafficType: REJECT

  InternetGateway:
    Type: 'AWS::EC2::InternetGateway'
    Properties:
      Tags:
        - Key: Network
          Value: Public
        - Key: Name
          Value: !Ref 'AWS::StackName'
  GatewayToInternet:
    Type: 'AWS::EC2::VPCGatewayAttachment'
    Properties:
      VpcId: !Ref Vpc
      InternetGatewayId: !Ref InternetGateway
  PublicSubnet1:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref Vpc
      AvailabilityZone: 
        Fn::Select: 
          - 0
          - Fn::GetAZs: ""
      CidrBlock: !Ref VpcPublicSubnet1CIDR
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Network
          Value: Public
        - Key: Name
          Value: !Ref 'AWS::StackName'
        - Key: 'kubernetes.io/role/elb'
          Value: '1'
        - Key: !Sub 'kubernetes.io/cluster/${AWS::StackName}'
          Value: 'shared'
  PublicSubnet2:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref Vpc
      AvailabilityZone: 
        Fn::Select: 
          - 1
          - Fn::GetAZs: ""
      CidrBlock: !Ref VpcPublicSubnet2CIDR
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Network
          Value: Public
        - Key: Name
          Value: !Ref 'AWS::StackName'
        - Key: 'kubernetes.io/role/elb'
          Value: '1'
        - Key: !Sub 'kubernetes.io/cluster/${AWS::StackName}'
          Value: 'shared'
  PublicSubnet3:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref Vpc
      AvailabilityZone: 
        Fn::Select: 
          - 2
          - Fn::GetAZs: ""
      CidrBlock: !Ref VpcPublicSubnet3CIDR
      MapPublicIpOnLaunch: false
      Tags:
        - Key: Network
          Value: Public
        - Key: Name
          Value: !Ref 'AWS::StackName'
        - Key: 'kubernetes.io/role/elb'
          Value: '1'
        - Key: !Sub 'kubernetes.io/cluster/${AWS::StackName}'
          Value: 'shared'
  PrivateSubnet1:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref Vpc
      AvailabilityZone: 
        Fn::Select: 
          - 0
          - Fn::GetAZs: ""
      CidrBlock: !Ref VpcPrivateSubnet1CIDR
      Tags:
        - Key: Network
          Value: Private
        - Key: Name
          Value: !Ref 'AWS::StackName'
        - Key: 'kubernetes.io/role/internal-elb'
          Value: '1'
        - Key: !Sub 'kubernetes.io/cluster/${AWS::StackName}'
          Value: 'shared'
  PrivateSubnet2:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref Vpc
      AvailabilityZone: 
        Fn::Select: 
          - 1
          - Fn::GetAZs: ""
      CidrBlock: !Ref VpcPrivateSubnet2CIDR
      Tags:
        - Key: Network
          Value: Private
        - Key: Name
          Value: !Ref 'AWS::StackName'
        - Key: 'kubernetes.io/role/internal-elb'
          Value: '1'
        - Key: !Sub 'kubernetes.io/cluster/${AWS::StackName}'
          Value: 'shared'
  PrivateSubnet3:
    Type: 'AWS::EC2::Subnet'
    Properties:
      VpcId: !Ref Vpc
      AvailabilityZone: 
        Fn::Select: 
          - 2
          - Fn::GetAZs: ""
      CidrBlock: !Ref VpcPrivateSubnet3CIDR
      Tags:
        - Key: Network
          Value: Private
        - Key: Name
          Value: !Ref 'AWS::StackName'
        - Key: 'kubernetes.io/role/internal-elb'
          Value: '1'
        - Key: !Sub 'kubernetes.io/cluster/${AWS::StackName}'
          Value: 'shared'
  NATGatewayEIP:
    Type: 'AWS::EC2::EIP'
    Properties:
      Domain: vpc
  NATGateway:
    Type: 'AWS::EC2::NatGateway'
    DependsOn: GatewayToInternet
    Properties:
      AllocationId: !GetAtt 
        - NATGatewayEIP
        - AllocationId
      SubnetId: !Ref PublicSubnet1
  PublicRouteTable:
    Type: 'AWS::EC2::RouteTable'
    DependsOn: GatewayToInternet
    Properties:
      VpcId: !Ref Vpc
      Tags:
        - Key: Network
          Value: Public
        - Key: Name
          Value: !Ref 'AWS::StackName'
  PublicRoute:
    Type: 'AWS::EC2::Route'
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway
  PublicSubnet1RouteAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    DependsOn: [ PublicRoute ]
    Properties:
      SubnetId: !Ref PublicSubnet1
      RouteTableId: !Ref PublicRouteTable
  PublicSubnet2RouteAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    DependsOn: [ PublicRoute ]
    Properties:
      SubnetId: !Ref PublicSubnet2
      RouteTableId: !Ref PublicRouteTable
  PublicSubnet3RouteAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    DependsOn: [ PublicRoute ]
    Properties:
      SubnetId: !Ref PublicSubnet3
      RouteTableId: !Ref PublicRouteTable
  PrivateRouteTable:
    Type: 'AWS::EC2::RouteTable'
    Properties:
      VpcId: !Ref Vpc
      Tags:
        - Key: Network
          Value: Private
        - Key: Name
          Value: !Ref 'AWS::StackName'
  PrivateRoute:
    Type: 'AWS::EC2::Route'
    Properties:
      RouteTableId: !Ref PrivateRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NATGateway
 
  PrivateSubnet1RouteAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    DependsOn: [ PrivateRoute ]
    Properties:
      SubnetId: !Ref PrivateSubnet1
      RouteTableId: !Ref PrivateRouteTable
  PrivateSubnet2RouteAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    DependsOn: [ PrivateRoute ]
    Properties:
      SubnetId: !Ref PrivateSubnet2
      RouteTableId: !Ref PrivateRouteTable
  PrivateSubnet3RouteAssociation:
    Type: 'AWS::EC2::SubnetRouteTableAssociation'
    DependsOn: [ PrivateRoute ]
    Properties:
      SubnetId: !Ref PrivateSubnet3
      RouteTableId: !Ref PrivateRouteTable

  VpcS3Endpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      PolicyDocument: 
        Version: 2012-10-17
        Statement: 
          - Effect: "Allow"
            Principal: "*"
            Action: 
              - "s3:Get*"
              - "s3:List*"
              - "s3:PutObject*"
              - "s3:DeleteObject*"
            Resource:
              - !Sub 'arn:aws:s3:::${UniverseBucket}'
              - !Sub 'arn:aws:s3:::${UniverseBucket}/*'
              - !Sub 'arn:aws:s3:::${CorporaBucket}'
              - !Sub 'arn:aws:s3:::${CorporaBucket}/*'
              - !Sub 'arn:aws:s3:::${TrailBucket}'
              - !Sub 'arn:aws:s3:::${TrailBucket}/*'
              - !Sub 'arn:aws:s3:::${CodeBucket}'
              - !Sub 'arn:aws:s3:::${CodeBucket}/*'
          - Effect: "Allow"
            Principal: "*"
            Action: 
              - "s3:*"
            Resource:
              - !Sub arn:aws:s3:::prod-${AWS::Region}-starport-layer-bucket/*

      RouteTableIds:
        - !Ref PrivateRouteTable
        - !Ref PublicRouteTable
      ServiceName: !Sub com.amazonaws.${AWS::Region}.s3
      VpcId: !Ref Vpc
  VpcDynamodbEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      RouteTableIds:
        - !Ref PrivateRouteTable
      ServiceName: !Sub com.amazonaws.${AWS::Region}.dynamodb
      VpcId: !Ref Vpc
  VpcEcrApiEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      SubnetIds:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
        - Ref: PrivateSubnet3
      PolicyDocument: 
        Version: 2012-10-17
        Statement: 
          - Effect: "Allow"
            Principal: "*"
            Action: 
              - "ecr:*"
            Resource: "*"
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ecr.api
      SecurityGroupIds:
        - !GetAtt VpcSecurityGroup.GroupId
      VpcEndpointType: 'Interface'
      VpcId: !Ref Vpc
  VpcEcrDkrEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      SubnetIds:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
        - Ref: PrivateSubnet3
      PolicyDocument: 
        Version: 2012-10-17
        Statement: 
          - 
            Effect: "Allow"
            Principal: "*"
            Action: 
              - "ecr:*"
            Resource: "*"
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ecr.dkr
      SecurityGroupIds:
        - !GetAtt VpcSecurityGroup.GroupId
      VpcEndpointType: 'Interface'
      VpcId: !Ref Vpc
  VpcSecretsManagerEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      SubnetIds:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
        - Ref: PrivateSubnet3
      PolicyDocument: 
        Version: 2012-10-17
        Statement: 
          - 
            Effect: "Allow"
            Principal: "*"
            Action: 
              - "secretsmanager:*"
            Resource: "*"
      ServiceName: !Sub com.amazonaws.${AWS::Region}.secretsmanager
      SecurityGroupIds:
        - !GetAtt VpcSecurityGroup.GroupId
      VpcEndpointType: 'Interface'
      VpcId: !Ref Vpc
  VpcEcsEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      SubnetIds:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
        - Ref: PrivateSubnet3
      PolicyDocument: 
        Version: 2012-10-17
        Statement: 
          - Effect: "Allow"
            Principal: "*"
            Action: 
              - "ecs:*"
            Resource: "*"
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ecs
      SecurityGroupIds:
        - !GetAtt VpcSecurityGroup.GroupId
      VpcEndpointType: 'Interface'
      VpcId: !Ref Vpc
  VpcEcsAgentEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      SubnetIds:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
        - Ref: PrivateSubnet3
      PolicyDocument: 
        Version: 2012-10-17
        Statement: 
          - Effect: "Allow"
            Principal: "*"
            Action: 
              - "ecs:*"
            Resource: "*"
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ecs-agent
      SecurityGroupIds:
        - !GetAtt VpcSecurityGroup.GroupId
      VpcEndpointType: 'Interface'
      VpcId: !Ref Vpc
  VpcEcsTelemetryEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Properties:
      SubnetIds:
        - Ref: PrivateSubnet1
        - Ref: PrivateSubnet2
        - Ref: PrivateSubnet3
      PolicyDocument: 
        Version: 2012-10-17
        Statement: 
          - Effect: "Allow"
            Principal: "*"
            Action: 
              - "ecs:*"
            Resource: "*"
      ServiceName: !Sub com.amazonaws.${AWS::Region}.ecs-telemetry
      SecurityGroupIds:
        - !GetAtt VpcSecurityGroup.GroupId
      VpcEndpointType: 'Interface'
      VpcId: !Ref Vpc

  VpcSecurityGroup:
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      GroupDescription: VPC security group
      VpcId: !Ref Vpc
      Tags:
        - Key: Name
          Value: !Ref 'AWS::StackName'

  VpcSecurityGroupCIDRIngressHttps:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      Description: Ingress from within the VPC security group for Https
      GroupId: !GetAtt VpcSecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      CidrIp: !Ref VpcCIDR

  VpcSecurityGroupIngressHttps:
    Type: 'AWS::EC2::SecurityGroupIngress'
    Properties:
      Description: Ingress from within the VPC security group for Https
      GroupId: !GetAtt VpcSecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443
      SourceSecurityGroupId: !GetAtt VpcSecurityGroup.GroupId

  VpcSecurityGroupCIDREgress: 
    Type: 'AWS::EC2::SecurityGroupEgress'
    Properties:
      Description: Egress rule for out bound traffic
      GroupId: !GetAtt VpcSecurityGroup.GroupId
      IpProtocol: tcp
      FromPort: 0
      ToPort: 65535
      CidrIp: '0.0.0.0/0'

  BatchServiceRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - batch.amazonaws.com
            Action: 
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSBatchServiceRole'
  
  BatchEc2InstanceProfile: 
    Type: AWS::IAM::InstanceProfile
    Properties: 
      Roles: 
        - !Ref BatchEc2InstanceRole

  BatchEc2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - "ec2.amazonaws.com"
            Action:
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - "arn:aws:iam::aws:policy/service-role/AmazonEC2ContainerServiceforEC2Role"

  BatchExecutionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - ecs-tasks.amazonaws.com
            Action: 
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy'
  
  StepFunctionsRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - states.amazonaws.com
            Action: 
              - "sts:AssumeRole"
      Policies:
        - PolicyName: steps-batch-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "batch:SubmitJob"
                Resource:
                  - !Ref JobQueue
                  - !Sub 'arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/*'
              - Effect: Allow
                Action:
                  - "batch:DescribeJobs"
                Resource:
                  - "*"
        - PolicyName: steps-logs-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "logs:CreateLogStream"
                  - "logs:DescribeLogStreams"
                Resource:
                  - !GetAtt  StateMachineLogGroup.Arn
              - Effect: Allow
                Action:
                  - "logs:PutLogEvents"
                Resource:
                  - !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:${StateMachineLogGroup}:log-stream:*
              - Effect: Allow
                Action:
                  - "logs:CreateLogDelivery"
                  - "logs:GetLogDelivery"
                  - "logs:UpdateLogDelivery"
                  - "logs:DeleteLogDelivery"
                  - "logs:ListLogDeliveries"
                  - "logs:PutResourcePolicy"
                  - "logs:DescribeResourcePolicies"
                  - "logs:DescribeLogGroups"
                Resource: "*"
        - PolicyName: steps-events-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "events:PutTargets"
                  - "events:PutRule"
                  - "events:DescribeRule"
                Resource: 
                  - !Sub arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/*

  BatchJobRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - ecs-tasks.amazonaws.com
            Action: 
              - "sts:AssumeRole"
      Policies:
        - PolicyName: 'batch-job-s3-policy'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: 
                  - "s3:Get*"
                  - "s3:List*"
                Resource:
                  - !Sub 'arn:aws:s3:::${UniverseBucket}'
                  - !Sub 'arn:aws:s3:::${UniverseBucket}/*'
                  - !Sub 'arn:aws:s3:::${CorporaBucket}'
                  - !Sub 'arn:aws:s3:::${CorporaBucket}/*'
                  - !Sub 'arn:aws:s3:::${CodeBucket}'
                  - !Sub 'arn:aws:s3:::${CodeBucket}/*'
              - Effect: Allow
                Action: 
                  - "s3:DeleteObject*"
                  - "s3:PutObject*"
                Resource:
                  - !Sub 'arn:aws:s3:::${CorporaBucket}'
                  - !Sub 'arn:aws:s3:::${CorporaBucket}/*'
        - PolicyName: batch-job-batch-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "batch:SubmitJob"
                Resource:
                  - !Ref JobQueue
                  - !Sub 'arn:aws:batch:${AWS::Region}:${AWS::AccountId}:job-definition/*'
              - Effect: Allow
                Action:
                  - "batch:DescribeJobs"
                  - "batch:TerminateJob"
                Resource:
                  - "*"

        - PolicyName: batch-job-dynamodb-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "dynamodb:*"
                Resource:
                  - !GetAtt CorpusTable.Arn

        - PolicyName: batch-job-glue-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                - "glue:CreateDatabase"
                - "glue:DeleteDatabase"
                - "glue:GetDatabase"
                - "glue:GetDatabases"
                - "glue:UpdateDatabase"
                - "glue:CreateTable"
                - "glue:DeleteTable"
                - "glue:BatchDeleteTable"
                - "glue:UpdateTable"
                - "glue:GetTable"
                - "glue:GetTables"
                - "glue:BatchCreatePartition"
                - "glue:CreatePartition"
                - "glue:DeletePartition"
                - "glue:BatchDeletePartition"
                - "glue:UpdatePartition"
                - "glue:GetPartition"
                - "glue:GetPartitions"
                - "glue:BatchGetPartition"
                Resource:
                  - !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:catalog'
                  - !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:database/*'
                  - !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:table/*'
                  - !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:userDefinedFunction/*'
              - Effect: Allow
                Action:
                  - "iam:PassRole"
                Resource:
                  - !GetAtt GlueServiceRole.Arn
        - PolicyName: batch-job-athena-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "athena:GetQueryExecution"
                  - "athena:GetQueryResults"
                  - "athena:StartQueryExecution"
                Resource:
                  - !Sub 'arn:aws:athena:${AWS::Region}:${AWS::AccountId}:workgroup/*'
                
  GlueServiceRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - glue.amazonaws.com
            Action: 
              - "sts:AssumeRole"
      ManagedPolicyArns:
        - 'arn:aws:iam::aws:policy/service-role/AWSGlueServiceRole'
      Policies:
        - PolicyName: 'batch-job-s3-policy'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: 
                  - "s3:GetObject"
                  - "s3:PutObject"
                  - "s3:DeleteObject*"
                Resource:
                  - !Sub 'arn:aws:s3:::${UniverseBucket}'
                  - !Sub 'arn:aws:s3:::${UniverseBucket}/*'
                  - !Sub 'arn:aws:s3:::${CorporaBucket}'
                  - !Sub 'arn:aws:s3:::${CorporaBucket}/*'

  CorpusTable:
    Type: AWS::DynamoDB::Table
    Properties:
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: corpus_id
          AttributeType: S
      KeySchema:
        - AttributeName: corpus_id
          KeyType: HASH

  BatchComputeEnvironment:
    Type: AWS::Batch::ComputeEnvironment
    Properties:
      ComputeEnvironmentName: !Sub '${AWS::StackName}'
      Type: MANAGED
      State: ENABLED
      ComputeResources:
        Type: !Ref BatchComputeType
        MaxvCpus: !Ref BatchComputeMax
        Subnets: 
          - Ref: PrivateSubnet1
          - Ref: PrivateSubnet2
          - Ref: PrivateSubnet3
        SecurityGroupIds:
          - !GetAtt VpcSecurityGroup.GroupId

      ServiceRole: !GetAtt BatchServiceRole.Arn
      Tags:
        Name: !Ref AWS::StackName

  
  JobQueue:
    Type: AWS::Batch::JobQueue
    Properties: 
      JobQueueName: !Sub '${AWS::StackName}'
      ComputeEnvironmentOrder: 
        - Order: 1
          ComputeEnvironment: !Ref BatchComputeEnvironment
      Priority: 1
      State: ENABLED
  JobDefintion:
    Type: AWS::Batch::JobDefinition
    Properties: 
      JobDefinitionName: !Sub '${AWS::StackName}'
      Type: container
      PlatformCapabilities: 
        - !Ref BatchComputeType
      ContainerProperties:
        Image: !Ref BatchImageEcrUri
        FargatePlatformConfiguration:
          PlatformVersion: "1.4.0"
        ExecutionRoleArn: !GetAtt BatchExecutionRole.Arn
        JobRoleArn: !GetAtt BatchJobRole.Arn
        ResourceRequirements:
          - Type: "VCPU"
            Value: "4"
          - Type: "MEMORY"
            Value: "8192"

  CpuInferenceJobDefintion:
    Type: AWS::Batch::JobDefinition
    Properties: 
      JobDefinitionName: !Sub '${AWS::StackName}-cpu-inference'
      Type: container
      PlatformCapabilities: 
        - !Ref BatchComputeType
      ContainerProperties:
        Image: !Ref BatchCpuInferenceImageEcrUri
        FargatePlatformConfiguration:
          PlatformVersion: "1.4.0"
        ExecutionRoleArn: !GetAtt BatchExecutionRole.Arn
        JobRoleArn: !GetAtt BatchJobRole.Arn
        ResourceRequirements:
          - Type: "VCPU"
            Value: "4"
          - Type: "MEMORY"
            Value: "8192"
         
  StateMachineLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:  
      LogGroupName: !Sub "${AWS::StackName}-state-machine"
      RetentionInDays: 90
      KmsKeyId: !GetAtt  KMSKey.Arn

  ECSLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:  
      LogGroupName: !Sub "${AWS::StackName}-ecs"
      RetentionInDays: 90
      KmsKeyId: !GetAtt  KMSKey.Arn


  DeleteCorpusStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties: 
      StateMachineName: !Sub "${AWS::StackName}-delete-corpus-state-machine"
      RoleArn: !GetAtt StepFunctionsRole.Arn
      LoggingConfiguration:
        Destinations: 
          -  CloudWatchLogsLogGroup: 
              LogGroupArn: !GetAtt StateMachineLogGroup.Arn
        IncludeExecutionData: true
        Level: "ALL"
      Definition: 
        Comment: "Steps for create corpus workflow"
        StartAt: "DeleteCorpusSuccess"
        States: 

          FailState:
            Type: "Fail"
            Cause: "StateMachine Failed"

          DeleteCorpusSuccess:
            Type: "Task"
            Resource: "arn:aws:states:::batch:submitJob.sync"
            ResultSelector:
              "Status.$": "$.Status"
            ResultPath: "$.StateMachine"
            End:  true
            Catch:
              - ErrorEquals: [ "States.TaskFailed" ]
                Next: "FailState"
                ResultPath: "$.error" 
            Parameters:
              JobQueue: !Sub "${AWS::StackName}"
              JobDefinition: !Sub "${AWS::StackName}"
              JobName: "delete-corpus-success"
              ContainerOverrides:
                Environment:
                  - Name: "S3_PYTHON_SCRIPT"
                    Value: !Sub "s3://${CodeBucket}/scripts/${ScriptsVersion}/delete_corpus_success.py"
                  - Name: "S3_JSON_CONFIG"
                    Value.$: "$.S3JsonConfig"
                  - Name: "AWS_DEFAULT_REGION"
                    Value: !Sub "${AWS::Region}"
              RetryStrategy:
                Attempts: 1

  CreateCorpusStateMachine:
    Type: AWS::StepFunctions::StateMachine
    Properties: 
      StateMachineName: !Sub "${AWS::StackName}-create-corpus-state-machine"
      RoleArn: !GetAtt StepFunctionsRole.Arn
      LoggingConfiguration:
        Destinations: 
          -  CloudWatchLogsLogGroup: 
              LogGroupArn: !GetAtt StateMachineLogGroup.Arn
        IncludeExecutionData: true
        Level: "ALL"
      Definition: 
        Comment: "Steps for create corpus"
        StartAt: "CreateCorpusManifest"
        States: 

          FailState:
            Type: "Fail"
            Cause: "StateMachine Failed"

          CreateCorpusFailed:
            Type: "Task"
            Resource: "arn:aws:states:::batch:submitJob.sync"
            ResultSelector:
              "Status.$": "$.Status"
            ResultPath: "$.StateMachine"
            Next:  "FailState"
            Parameters:
              JobQueue: !Sub "${AWS::StackName}"
              JobDefinition: !Sub "${AWS::StackName}"
              JobName: "create-corpus-failed"
              ContainerOverrides:
                Environment:
                  - Name: "S3_PYTHON_SCRIPT"
                    Value: !Sub "s3://${CodeBucket}/scripts/${ScriptsVersion}/create_corpus_failed.py"
                  - Name: "S3_JSON_CONFIG"
                    Value.$: "$.S3JsonConfig"
                  - Name: "S3_REQUIREMENTS_TXT"
                    Value: !Sub "s3://${CodeBucket}/scripts/${ScriptsVersion}/create_corpus_requirements.txt"
                  - Name: "AWS_DEFAULT_REGION"
                    Value: !Sub "${AWS::Region}"
              RetryStrategy:
                Attempts: 1

          CreateCorpusManifest:
            Type: "Task"
            Resource: "arn:aws:states:::batch:submitJob.sync"
            ResultSelector:
              "Status.$": "$.Status"
            ResultPath: "$.StateMachine"
            Next:  "ComputeNgramMetrics"
            Catch:
              - ErrorEquals: [ "States.TaskFailed" ]
                Next: "CreateCorpusFailed"
                ResultPath: "$.error" 
            Parameters:
              JobQueue: !Sub "${AWS::StackName}"
              JobDefinition: !Sub "${AWS::StackName}"
              JobName: "create-corpus-manifest"
              ContainerOverrides:
                Environment:
                  - Name: "S3_PYTHON_SCRIPT"
                    Value: !Sub "s3://${CodeBucket}/scripts/${ScriptsVersion}/create_corpus_manifest.py"
                  - Name: "S3_JSON_CONFIG"
                    Value.$: "$.S3JsonConfig"
                  - Name: "AWS_DEFAULT_REGION"
                    Value: !Sub "${AWS::Region}"
              RetryStrategy:
                Attempts: 1

          ComputeNgramMetrics:
            Type: "Task"
            Resource: "arn:aws:states:::batch:submitJob.sync"
            ResultSelector:
              "Status.$": "$.Status"
            ResultPath: "$.StateMachine"
            Next:  "ComputePhrasePiece"
            Catch:
              - ErrorEquals: [ "States.TaskFailed" ]
                Next: "CreateCorpusFailed"
                ResultPath: "$.error" 
            Parameters:
              JobQueue: !Sub "${AWS::StackName}"
              JobDefinition: !Sub "${AWS::StackName}-cpu-inference"
              JobName: "compute-ngram-metrics"
              ContainerOverrides:
                Environment:
                  - Name: "S3_PYTHON_SCRIPT"
                    Value: !Sub "s3://${CodeBucket}/scripts/${ScriptsVersion}/compute_ngram_metrics.py"
                  - Name: "S3_JSON_CONFIG"
                    Value.$: "$.S3JsonConfig"
                  - Name: "AWS_DEFAULT_REGION"
                    Value: !Sub "${AWS::Region}"
              RetryStrategy:
                Attempts: 1

          ComputePhrasePiece:
            Type: "Task"
            Resource: "arn:aws:states:::batch:submitJob.sync"
            ResultSelector:
              "Status.$": "$.Status"
            ResultPath: "$.StateMachine"
            Next:  "ComputeKeyphrases"
            Catch:
              - ErrorEquals: [ "States.TaskFailed" ]
                Next: "CreateCorpusFailed"
                ResultPath: "$.error" 
            Parameters:
              JobQueue: !Sub "${AWS::StackName}"
              JobDefinition: !Sub "${AWS::StackName}"
              JobName: "compute-phrase-piece"
              ContainerOverrides:
                Environment:
                  - Name: "S3_PYTHON_SCRIPT"
                    Value: !Sub "s3://${CodeBucket}/scripts/${ScriptsVersion}/compute_phrase_piece.py"
                  - Name: "S3_JSON_CONFIG"
                    Value.$: "$.S3JsonConfig"
                  - Name: "AWS_DEFAULT_REGION"
                    Value: !Sub "${AWS::Region}"
              RetryStrategy:
                Attempts: 1

          ComputeKeyphrases:
            Type: "Task"
            Resource: "arn:aws:states:::batch:submitJob.sync"
            ResultSelector:
              "Status.$": "$.Status"
            ResultPath: "$.StateMachine"
            Next:  "CreateCorpusSuccess"
            Catch:
              - ErrorEquals: [ "States.TaskFailed" ]
                Next: "CreateCorpusFailed"
                ResultPath: "$.error" 
            Parameters:
              JobQueue: !Sub "${AWS::StackName}"
              JobDefinition: !Sub "${AWS::StackName}-cpu-inference"
              JobName: "compute-keyphrases"
              ContainerOverrides:
                Environment:
                  - Name: "S3_PYTHON_SCRIPT"
                    Value: !Sub "s3://${CodeBucket}/scripts/${ScriptsVersion}/compute_keyphrases.py"
                  - Name: "S3_JSON_CONFIG"
                    Value.$: "$.S3JsonConfig"
                  - Name: "AWS_DEFAULT_REGION"
                    Value: !Sub "${AWS::Region}"
              RetryStrategy:
                Attempts: 1

          CreateCorpusSuccess:
            Type: "Task"
            Resource: "arn:aws:states:::batch:submitJob.sync"
            ResultSelector:
              "Status.$": "$.Status"
            ResultPath: "$.StateMachine"
            End:  true
            Catch:
              - ErrorEquals: [ "States.TaskFailed" ]
                Next: "CreateCorpusFailed"
                ResultPath: "$.error" 
            Parameters:
              JobQueue: !Sub "${AWS::StackName}"
              JobDefinition: !Sub "${AWS::StackName}"
              JobName: "create-corpus-success"
              ContainerOverrides:
                Environment:
                  - Name: "S3_PYTHON_SCRIPT"
                    Value: !Sub "s3://${CodeBucket}/scripts/${ScriptsVersion}/create_corpus_success.py"
                  - Name: "S3_JSON_CONFIG"
                    Value.$: "$.S3JsonConfig"
                  - Name: "S3_REQUIREMENTS_TXT"
                    Value: !Sub "s3://${CodeBucket}/scripts/${ScriptsVersion}/create_corpus_requirements.txt"
                  - Name: "AWS_DEFAULT_REGION"
                    Value: !Sub "${AWS::Region}"
              RetryStrategy:
                Attempts: 1

  LambdaFunctionRole:
    Type: "AWS::IAM::Role"
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - lambda.amazonaws.com
            Action: 
              - "sts:AssumeRole"
      Policies:
        - PolicyName: 'lambda-s3-policy'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: 
                  - "s3:Get*"
                  - "s3:List*"
                  - "s3:DeleteObject*"
                  - "s3:PutObject*"
                Resource:
                  - !Sub 'arn:aws:s3:::${CorporaBucket}'
                  - !Sub 'arn:aws:s3:::${CorporaBucket}/*'
                  
        - PolicyName: lambda-logs-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource:
                  - "arn:aws:logs:*:*:*"
        - PolicyName: 'lambda-ec2-policy'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateNetworkInterface
                  - ec2:DescribeNetworkInterfaces
                  - ec2:DeleteNetworkInterface
                Resource: '*'
        - PolicyName: 'lambda-states-policy'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - states:StartExecution
                Resource:
                  - !Ref CreateCorpusStateMachine
                  - !Ref DeleteCorpusStateMachine
              - Effect: Allow
                Action:
                  - states:DescribeExecution
                Resource:
                  - !Sub arn:aws:states:${AWS::Region}:${AWS::AccountId}:execution:${CreateCorpusStateMachine.Name}:*
                  - !Sub arn:aws:states:${AWS::Region}:${AWS::AccountId}:execution:${DeleteCorpusStateMachine.Name}:*
        - PolicyName: lambda-dynamodb-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "dynamodb:*"
                Resource:
                  - !GetAtt CorpusTable.Arn

        - PolicyName: lambda-glue-policy
          PolicyDocument:
            Statement:
              - Effect: Allow
                Action:
                  - "glue:CreateDatabase"
                Resource:
                  - !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:catalog'
                  - !Sub 'arn:aws:glue:${AWS::Region}:${AWS::AccountId}:database/*'

  DeleteCorpusFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: 'python3.9'
      Handler: 'delete_corpus_lambda.lambda_handler'
      Role: !GetAtt LambdaFunctionRole.Arn
      Timeout: 900
      MemorySize: 128
      VpcConfig:
        SecurityGroupIds:
          - !GetAtt VpcSecurityGroup.GroupId
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
          - !Ref PrivateSubnet3
      ReservedConcurrentExecutions: 10
      Environment:
        Variables:
          delete_corpus_sm_arn: !Ref DeleteCorpusStateMachine
          corpora_bucket: !Sub "${CorporaBucket}"
          batch_job_queue: !Sub "${AWS::StackName}"
          batch_job_definition: !Sub "${AWS::StackName}"
          corpus_table: !Ref CorpusTable
      Code:
        S3Bucket: !Ref CodeBucket
        S3Key: !Sub  "lambda/${LambdaFunctionsVersion}/delete_corpus_lambda.zip"

  CreateCorpusFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: 'python3.9'
      Handler: 'create_corpus_lambda.lambda_handler'
      Role: !GetAtt LambdaFunctionRole.Arn
      Timeout: 900
      MemorySize: 128
      VpcConfig:
        SecurityGroupIds:
          - !GetAtt VpcSecurityGroup.GroupId
        SubnetIds:
          - !Ref PrivateSubnet1
          - !Ref PrivateSubnet2
          - !Ref PrivateSubnet3
      ReservedConcurrentExecutions: 10
      Environment:
        Variables:
          create_corpus_sm_arn: !Ref CreateCorpusStateMachine
          corpora_bucket: !Ref CorporaBucket
          batch_job_queue: !Sub "${AWS::StackName}"
          batch_job_definition: !Sub "${AWS::StackName}"
          cpu_inference_batch_job_definition: !Sub "${AWS::StackName}-cpu-inference"
          corpus_table: !Ref CorpusTable

      Code:
        S3Bucket: !Ref CodeBucket
        S3Key: !Sub "lambda/${LambdaFunctionsVersion}/create_corpus_lambda.zip"


  TrailBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      AccessControl: LogDeliveryWrite
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: 'AES256'
      LoggingConfiguration:
        LogFilePrefix: !Sub '${AWS::StackName}-trail-bucket-logs'
      OwnershipControls: 
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain

  CorporaBucket:
    Type: 'AWS::S3::Bucket'
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: 'AES256'
      LoggingConfiguration:
        DestinationBucketName: !Ref TrailBucket
        LogFilePrefix: !Sub '${AWS::StackName}-corpora-bucket-logs'
      OwnershipControls: 
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain